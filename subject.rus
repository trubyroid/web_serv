Протокол передачи гипертекста (HTTP) — это прикладной протокол для распределенных, совместных информационных систем гипермедиа.
HTTP является основой передачи данных для World Wide Web, где гипертекстовые документы содержат гиперссылки на другие ресурсы,
к которым пользователь может легко получить доступ.
Например, щелчком мыши или касанием экрана в веб-браузере. HTTP был разработан для облегчения работы с гипертекстом и Всемирной паутиной.
Основная функция веб-сервера — хранить, обрабатывать и доставлять веб-страницы клиентам. Связь между клиентом и сервером 
осуществляется с использованием протокола передачи гипертекста (HTTP).
Доставляемые страницы чаще всего представляют собой HTML-документы, которые могут включать изображения, таблицы стилей 
и сценарии в дополнение к текстовому содержимому.
Для веб-сайта с высокой посещаемостью можно использовать несколько веб-серверов.
Пользовательский агент, обычно веб-браузер или веб-сканер, инициирует связь, запрашивая определенный ресурс с использованием HTTP, 
и сервер отвечает содержимым этого ресурса или сообщением об ошибке, если не может этого сделать. Ресурс обычно представляет собой реальный файл
во вторичном хранилище сервера, но это не обязательно так и зависит от того, как реализован веб-сервер.
Хотя основной функцией является предоставление контента, полная реализация HTTP также включает способы получения контента от клиентов. 
Эта функция используется для отправки веб-форм, включая загрузку файлов.

Основные правила
• Ваша программа не должна давать сбоев ни при каких обстоятельствах (даже если ей не хватает памяти) и не должна неожиданно завершать работу.
Если это произойдет, ваш проект будет считаться нефункциональным, а ваша оценка будет равна 0.
• Вы должны сдать Makefile, который скомпилирует ваши исходные файлы. Он не должен повторно связываться.
• Ваш Makefile должен как минимум содержать правила:
$(NAME), all, clean, fclean и re.
• Скомпилируйте свой код с помощью C++ и флагов -Wall -Wextra -Werror
• Ваш код должен соответствовать стандарту C++ 98. Затем он все равно должен скомпилироваться, если вы добавите флаг -std=c++98.
• Старайтесь всегда разрабатывать с использованием как можно большего числа возможностей C++ (например, выбирайте <cstring> вместо <string.h>). 
Вам разрешено использовать функции C, но всегда предпочитайте их версии C++, если это возможно.
• Запрещены любые внешние библиотеки и библиотеки Boost.

Вы должны написать HTTP-сервер на C++ 98.
Ваш исполняемый файл будет запущен следующим образом: ./webserv [файл конфигурации]

Даже если в теме и шкале оценок упоминается poll(),
вы можете использовать любой эквивалент, такой как select(), kqueue() или epoll().

Пожалуйста, прочтите RFC и выполните несколько тестов с telnet и NGINX, прежде чем начинать этот проект.
Даже если вам не нужно реализовывать все RFC, их чтение поможет для разработки необходимых функций.

Требования
• Ваша программа должна принимать файл конфигурации в качестве аргумента или использовать путь по умолчанию.
• Вы не можете запустить другой веб-сервер.
• Ваш сервер никогда не должен блокироваться, а клиент при необходимости может быть правильно возвращен.
• Он должен быть неблокирующим и использовать только 1 poll() (или аналогичный) для всех операций ввода-вывода между клиентом и сервером (включая прослушивание).
• poll() (или аналогичный) должен проверять чтение и запись одновременно.
• Вы никогда не должны выполнять операцию чтения или записи, не пройдя через функцию poll() (или аналогичную).
• Проверка значения errno строго запрещена после операции чтения или записи.
• Вам не нужно использовать poll() (или аналогичный) перед чтением файла конфигурации.

Поскольку вы должны использовать неблокирующие файловые дескрипторы,
можно использовать функции чтения/приема или записи/отправки без poll()
(или эквивалент), и ваш сервер не будет блокироваться.
Но это будет потреблять больше системных ресурсов.
Таким образом, если вы попытаетесь прочитать/получить или записать/отправить любой файловый дескриптор без использования poll() (или его эквивалента), 
ваша оценка будет равна 0.

Вы можете использовать любой макрос и определять как FD_SET, FD_CLR, FD_ISSET, FD_ZERO (понимание того, что и как они делают, очень полезно).
• Запрос к вашему серверу никогда не должен зависать навсегда.
• Ваш сервер должен быть совместим с выбранным вами веб-браузером.
• Мы будем считать, что NGINX совместим с HTTP 1.1 и может использоваться для сравнения заголовков и ответов.
• Коды состояния ответа HTTP должны быть точными.
• Ваш сервер должен иметь страницы ошибок по умолчанию, если они не предоставлены.
• Вы не можете использовать fork для чего-то другого, кроме CGI (например, PHP или Python и т. д.).
• Вы должны иметь возможность обслуживать полностью статический веб-сайт.
• Клиенты должны иметь возможность загружать файлы.
• Вам нужны как минимум методы GET, POST и DELETE.
• Стресс-тесты вашего сервера. Он должен оставаться доступным любой ценой.
• Ваш сервер должен иметь возможность прослушивать несколько портов (см. Файл конфигурации).

Только для MacOS
Поскольку MacOS не реализует write() так же, как другие Unix
ОС вам разрешено использовать fcntl().
Вы должны использовать файловые дескрипторы в неблокирующем режиме, чтобы получить
поведение аналогично другим ОС Unix.
Однако вам разрешено использовать fcntl() только следующим образом: fcntl(fd, F_SETFL, O_NONBLOCK);
Любой другой флаг запрещен.

Вы можете получить вдохновение от «серверной» части NGINX.
конфигурационный файл.

В файле конфигурации вы должны иметь возможность:
• Выберите порт и хост каждого «сервера».
• Настройте server_names или нет.
• Первый сервер для host:port будет использоваться по умолчанию для этого host:port (это означает, что он будет отвечать на все запросы, 
которые не принадлежат другому серверу).
• Настройка страниц ошибок по умолчанию.
• Ограничьте размер тела клиента.
• Настройте маршруты с одним или несколькими из следующих правил/конфигураций (маршруты не будут использовать регулярное выражение):
◦ Определите список допустимых HTTP-методов для маршрута.
◦ Определите перенаправление HTTP.
◦ Определите каталог или файл, в котором следует искать файл (например, если URL-адрес /kapouet ведет к /tmp/www, 
URL-адрес /kapouet/pouic/toto/pouet — это /tmp/www/pouic/toto/pouet). ).
◦ Включить или выключить список каталогов.

◦ Установите файл по умолчанию для ответа, если запрос является каталогом.
◦ Выполнение CGI на основе определенного расширения файла (например, .php).
◦ Разрешите маршруту принимать загруженные файлы и настройте место их сохранения.
∗ Вам интересно, что такое компьютерная графика?
* Поскольку вы не будете вызывать CGI напрямую, используйте полный путь как PATH_INFO.
* Просто помните, что для фрагментированного запроса ваш сервер должен его разархивировать, и CGI будет ожидать EOF как конец тела.
* То же самое для вывода CGI. Если CGI не возвращает content_length, EOF отмечает конец возвращаемых данных.
* Ваша программа должна вызывать CGI с запрошенным файлом в качестве первого аргумента.
* CGI следует запускать в правильном каталоге для доступа к файлам с относительным путем.
* Ваш сервер должен работать с одним CGI (php-CGI, Python и т. д.).
Вы должны предоставить некоторые файлы конфигурации и базовые файлы по умолчанию для тестирования и демонстрации работы каждой функции во время оценки.

Если у вас есть вопрос об одном поведении, вам следует сравнить поведение вашей программы с поведением NGINX.
Например, проверьте, как работает server_name.
Мы поделились с вами небольшим тестером. Его не обязательно проходить
если с вашим браузером и тестами все работает нормально, но это может помочь
вы охотитесь за некоторыми ошибками.

Главное — это устойчивость. Ваш сервер никогда не должен умереть.
Не тестируйте только с одной программой. Пишите свои тесты с более
удобный язык, такой как Python или Golang и так далее. Даже на C или C++, если хотите.

Представление и экспертная оценка
Сдайте задание в своем репозитории Git, как обычно. Во время защиты будет оцениваться только работа внутри вашего репозитория. 
Не стесняйтесь перепроверять имена ваших файлов, чтобы убедиться, что они верны.